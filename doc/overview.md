# Transborder events overview

Transborder event is an event where event producer is on one side of web application (front or back) and event consumer
is on the other side (back or front respectively).

IMAGE SHOULD BE HERE

There is a technology to transfer data from front to back - HTTP requests, and there is a technology to transfer data
from back to front - SSE (Server Sent Events). All we need is to combine these technologies - send HTTP requests (POST)
from front to back (if front emits a transborder event or responds to backend event) or send SSE message from back to
front (if back emits a transborder event or responds to frontend event).

![POST and SSE](img/overview_post_sse.webp)

## Open SSE connection

There is one problem - the back cannot send SSE messages to the front until the front opens a connection to the back.
So, first of all, the front should open SSE connection to the back and identify yourself:

```js
const url = `${sseHandlerAddress}/${frontId}`;
const source = new EventSource(url);
```

Here `sseHandlerAddress` is an address of the backend handler to process SSE related activity and `frontId` is an
identifier of the front to separates different fronts (one back - many fronts).

## Front identification

Frontend is an area in a browser that has own resources - cookies, IDB, cache store, etc. Different frontends cannot use
the same data stored in cookies, IDB, cache store. Frontend is a client-side representation of a web application. Web
application, usually, has one backend (back) and a lot of frontends (fronts). So, every front should have its own ID to
allow back to separate requests from different fronts.

## Session identification

If the user opens the same web application in two tabs, two different SSE connections should be opened because the user
can perform different actions in different tabs (can produce different transborder events).

## Identity initialization

Launch `TeqFw_Web_Event_Front_Mod_Identity_Front.init` method before any other activities:

```js
export default class Dev_Front_App {
    constructor(spec) {
        /** @type {TeqFw_Web_Event_Front_Mod_Identity_Front} */
        const modIdentity = spec['TeqFw_Web_Event_Front_Mod_Identity_Front$'];

        this.init = async function (fnPrintout) {
            await modIdentity.init();
        }
    }
}
```

This method generates new front UUID and keys pair for asymmetric encryption and registers front UUID and public key on
the back. Method uses `TeqFw_Web_Event_Front_Web_Connect_Front_Register` action to send data to backend.

## Stream identification

Each SSE-stream has own ID generated by backend (streamUuid,
see `TeqFw_Web_Event_Back_Mod_Server_Handler_Reverse.process.createStream`). All streams are registered
in `TeqFw_Web_Event_Back_Mod_Registry_Stream` registry.

## Front authentication

The first back-to-front message on newly opened SSE connection is authentication message (
see `TeqFw_Web_Event_Back_Web_Handler_Stream_Open_A_Stream.act.authenticateStream`). Structure of data to encrypt
and sign is defined in `TeqFw_Web_Event_Shared_Dto_Stream_Auth.Dto`:

```json
{
  "backUuid": "b112e6ee-093a-4053-bd16-4c8888a5fc78",
  "streamUuid": "5b302ea4-1fa0-49f2-9708-fbeaeb7a33e1"
}
```

Encryption result is sent to the front as plain string:

```text
xu0Vv3FVLciUQ/5MP3HeqKcHPSvqDzyp+6pNHtf94iMKPh0t8UoG6fiT6ongovqVgUbnL8t5FVRTTFVDtCNp6iS2tcY6TJrBZj+xhHwtt/amoQq2q4Jy5MKxmoJqFhtGcgKd6akVk9WrwDcKBScjkJPN10bUFPbGCVj5j3/QIwp0P5VzRJrE3pj1HNDWG4pOPXnFPjdGgDy5
```

Front decrypts and verifies payload in `TeqFw_Web_Event_Front_Web_Connect_Stream_Open.act.onAuthenticate` function then
returns streamUuid back to server as metadata of regular event (`...`).

Аутентификация не должна идти через event'ы - там уже идут события после аутентификации (потоки активированы).

Самый первый запрос - регистрация фронта. Если фронт не имеет в IDB данных по собственной идентичности, то он должен
сгенерировать новую идентичность и зарегистрировать её на бэке. Подтверждением регистрации служит frontBid (добавляется
к DTO в IDB - `TeqFw_Web_Event_Front_Dto_Identity_Front.Dto`).

Следующий шаг - установление SSE-соединения (`TeqFw_Web_Event_Front_Web_Connect_Stream_Open`). Если на фронте есть
frontBid, значит publicKey фронта уже зарегистрирован на бэке, можно открывать SSE-соединение. Типовой URL:

```text
https://.../wero/09895c45-8b25-47ea-84f7-cfa55045855d
```

Инициатива открытия находится на стороне фронта. Бэк-обработчик `TeqFw_Web_Event_Back_Web_Handler_Stream_Open`
извлекает frontUuid из GET-запроса, отправляет SSE-заголовки фронту и регистрирует новый поток во внутреннем реестре,
назначая ему `streamUuid`. Поток во внутреннем реестре отмечается как непроверенный, все события фронта, приходящие по
этому потоку игнорируются до момента аутентификации фронта.

Для аутентификации фронта, запросившего SSE-соединение, бэк по `frontUuid` извлекает из RDB открытый ключ
фронта, шифрует им `streamUuid`, добавляет к данным собственный публичный ключ (`backKey`) и свой
идентификатор (`backUuid`), после чего отправляет данные на
фронт (`TeqFw_Web_Event_Back_Web_Handler_Stream_Open_A_Stream.act.authenticateStream`).

Фронт в методе `TeqFw_Web_Event_Front_Web_Connect_Stream_Open.act.onAuthenticate` принимает `backUuid` и публичный ключ
сервера, расшифровывает `streamUuid` и сохраняет данные в модели `TeqFw_Web_Event_Front_Mod_Identity_Back`. После чего
отправляет `streamUuid` обратно на бэк через коннектор `...` для активации обратного потока событий.

Обработчик `TeqFw_Web_Event_Back_Web_Handler_Stream_Activate` по полученному `streamUuid` находит и активирует
соответствующий поток (если он существует) и возвращает 'true' обратно.
